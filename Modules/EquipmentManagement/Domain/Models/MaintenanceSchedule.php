<?php

namespace Modules\EquipmentManagement\Domain\Models;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class MaintenanceSchedule extends Model
{
    use HasFactory, SoftDeletes;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int;
use string>
     */
    protected $fillable = [
        'title',
        'description',
        'equipment_id',
        'frequency_type',
        'frequency_value',
        'frequency_unit',
        'start_date',
        'end_date',
        'last_generated',
        'next_due_date',
        'priority',
        'is_active',
        'created_by',
        'updated_by',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'start_date' => 'datetime',
        'end_date' => 'datetime',
        'last_generated' => 'datetime',
        'next_due_date' => 'datetime',
        'is_active' => 'boolean',
    ];

    // Priority constants
    const PRIORITY_HIGH = 1;
    const PRIORITY_MEDIUM = 3;
    const PRIORITY_LOW = 5;

    // Frequency types
    const FREQUENCY_ONE_TIME = 'one-time';
    const FREQUENCY_DAILY = 'daily';
    const FREQUENCY_WEEKLY = 'weekly';
    const FREQUENCY_MONTHLY = 'monthly';
    const FREQUENCY_QUARTERLY = 'quarterly';
    const FREQUENCY_YEARLY = 'yearly';
    const FREQUENCY_USAGE_BASED = 'usage-based';

    /**
     * Get the equipment that the schedule is for.
     */
    public function equipment(): BelongsTo
    {
        return $this->belongsTo(Equipment::class);
    }

    /**
     * Get the tasks generated by this schedule.
     */
    public function tasks(): HasMany
    {
        return $this->hasMany(MaintenanceTask::class, 'maintenance_schedule_id');
    }

    /**
     * Get the user that created the schedule.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    /**
     * Get the user that last updated the schedule.
     */
    public function updater(): BelongsTo
    {
        return $this->belongsTo(User::class, 'updated_by');
    }

    /**
     * Scope a query to only include active schedules.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include inactive schedules.
     */
    public function scopeInactive($query)
    {
        return $query->where('is_active', false);
    }

    /**
     * Scope a query to only include one-time schedules.
     */
    public function scopeOneTime($query)
    {
        return $query->where('frequency_type', self::FREQUENCY_ONE_TIME);
    }

    /**
     * Scope a query to only include recurring schedules.
     */
    public function scopeRecurring($query)
    {
        return $query->where('frequency_type', '!=', self::FREQUENCY_ONE_TIME);
    }

    /**
     * Scope a query to only include usage-based schedules.
     */
    public function scopeUsageBased($query)
    {
        return $query->where('frequency_type', self::FREQUENCY_USAGE_BASED);
    }

    /**
     * Scope a query to only include time-based schedules.
     */
    public function scopeTimeBased($query)
    {
        return $query->where('frequency_type', '!=', self::FREQUENCY_USAGE_BASED);
    }

    /**
     * Scope a query to only include schedules due for task generation.
     */
    public function scopeDueForGeneration($query)
    {
        return $query->active()
            ->where(function ($q) {
                $q->whereNull('last_generated')
                  ->orWhere('next_due_date', '<=', Carbon::now());
            })
            ->where(function ($q) {
                $q->whereNull('end_date')
                  ->orWhere('end_date', '>=', Carbon::now());
            });
    }

    /**
     * Generate the next maintenance task for this schedule.
     *
     * @return MaintenanceTask|null;
     */
    public function generateNextTask()
    {
        // Check if schedule is active and within date range
        if (!$this->is_active) {
            return null;
        }

        if ($this->end_date && $this->end_date < Carbon::now()) {
            return null;
        }

        // For one-time schedules, check if a task has already been generated
        if ($this->frequency_type === self::FREQUENCY_ONE_TIME && $this->last_generated) {
            return null;
        }

        $scheduledDate = $this->determineNextTaskDate();

        // Create the task
        $task = new MaintenanceTask([
            'title' => $this->title,
            'description' => $this->description,
            'equipment_id' => $this->equipment_id,
            'maintenance_schedule_id' => $this->id,
            'status' => MaintenanceTask::STATUS_PENDING,
            'scheduled_date' => $scheduledDate,
            'estimated_duration' => $this->getEstimatedDuration(),
            'created_by' => $this->created_by,
        ]);

        $task->save();

        // Update the schedule's last generated and next due date
        $this->last_generated = Carbon::now();
        $this->next_due_date = $this->calculateNextDueDate($scheduledDate);
        $this->save();

        return $task;
    }

    /**
     * Determine the scheduled date for the next task.
     *
     * @return Carbon;
     */
    protected function determineNextTaskDate()
    {
        // For first-time task generation
        if (!$this->last_generated) {
            return $this->start_date;
        }

        // For one-time schedules
        if ($this->frequency_type === self::FREQUENCY_ONE_TIME) {
            return $this->start_date;
        }

        // For recurring schedules
        switch ($this->frequency_type) {
            case self::FREQUENCY_DAILY:
                return $this->calculateNextDateByDays($this->frequency_value ?: 1);
;
            case self::FREQUENCY_WEEKLY:
                return $this->calculateNextDateByDays(($this->frequency_value ?: 1) * 7);
;
            case self::FREQUENCY_MONTHLY:
                return $this->calculateNextDateByMonths($this->frequency_value ?: 1);
;
            case self::FREQUENCY_QUARTERLY:
                return $this->calculateNextDateByMonths(($this->frequency_value ?: 1) * 3);
;
            case self::FREQUENCY_YEARLY:
                return $this->calculateNextDateByYears($this->frequency_value ?: 1);
;
            case self::FREQUENCY_USAGE_BASED:
                // For usage-based schedules, we default to a 30-day interval
                // but this should be adjusted based on actual equipment usage data
                return $this->calculateNextDateByDays(30);
;
            default:
                return Carbon::now();
        }
    }

    /**
     * Calculate the next due date based on the scheduled date.
     *
     * @param Carbon $scheduledDate
     * @return Carbon;
     */
    protected function calculateNextDueDate(Carbon $scheduledDate)
    {
        // For one-time schedules, next due date is null
        if ($this->frequency_type === self::FREQUENCY_ONE_TIME) {
            return null;
        }

        // For recurring schedules, next due date is the same as scheduled date
        return $scheduledDate;
    }

    /**
     * Calculate next date by adding days.
     *
     * @param int $days
     * @return Carbon;
     */
    protected function calculateNextDateByDays($days)
    {
        return Carbon::now()->addDays($days);
    }

    /**
     * Calculate next date by adding months.
     *
     * @param int $months
     * @return Carbon;
     */
    protected function calculateNextDateByMonths($months)
    {
        return Carbon::now()->addMonths($months);
    }

    /**
     * Calculate next date by adding years.
     *
     * @param int $years
     * @return Carbon;
     */
    protected function calculateNextDateByYears($years)
    {
        return Carbon::now()->addYears($years);
    }

    /**
     * Get the estimated duration for tasks.
     *
     * @return int;
     */
    protected function getEstimatedDuration()
    {
        // Default to 60 minutes for now
        // Could be customized based on task complexity, equipment type, etc.
        return 60;
    }

    /**
     * Check if the schedule is a one-time schedule.
     *
     * @return bool;
     */
    public function isOneTime()
    {
        return $this->frequency_type === self::FREQUENCY_ONE_TIME;
    }

    /**
     * Check if the schedule is a recurring schedule.
     *
     * @return bool;
     */
    public function isRecurring()
    {
        return $this->frequency_type !== self::FREQUENCY_ONE_TIME;
    }

    /**
     * Check if the schedule is a usage-based schedule.
     *
     * @return bool;
     */
    public function isUsageBased()
    {
        return $this->frequency_type === self::FREQUENCY_USAGE_BASED;
    }

    /**
     * Get the priority level text.
     *
     * @return string;
     */
    public function getPriorityText()
    {
        switch ($this->priority) {
            case self::PRIORITY_HIGH:
                return 'High';
            case self::PRIORITY_MEDIUM:
                return 'Medium';
            case self::PRIORITY_LOW:
                return 'Low';
            default:
                return 'Medium';
        }
    }

    /**
     * Get the frequency text.
     *
     * @return string;
     */
    public function getFrequencyText()
    {
        if ($this->frequency_type === self::FREQUENCY_ONE_TIME) {
            return 'One Time';
        }

        if ($this->frequency_type === self::FREQUENCY_USAGE_BASED) {
            return "Every {$this->frequency_value} {$this->frequency_unit}";
        }

        $value = $this->frequency_value ?: 1;
        $type = ucfirst($this->frequency_type);

        return $value > 1 ? "Every {$value} {$type}s" : "Every {$type}";
    }

    /**
     * Get the formatted start date.
     *
     * @return string;
     */
    public function getStartDateFormatted()
    {
        return $this->start_date ? $this->start_date->format('Y-m-d') : '';
    }

    /**
     * Get the formatted end date.
     *
     * @return string;
     */
    public function getEndDateFormatted()
    {
        return $this->end_date ? $this->end_date->format('Y-m-d') : 'No End Date';
    }

    /**
     * Get the formatted next due date.
     *
     * @return string;
     */
    public function getNextDueDateFormatted()
    {
        return $this->next_due_date ? $this->next_due_date->format('Y-m-d') : 'Not Scheduled';
    }
}






